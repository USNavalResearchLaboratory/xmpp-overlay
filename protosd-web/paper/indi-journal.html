<html>
<head>
    <title>INDI Journal Paper</title>

    <link rel="stylesheet" type="text/css" href="/css/protosd.css" />

</head>
<body>

<div class="header">
    <div class="floatleft">
        <a href="/index.html"><img src="/icons/dashboard.png"></a>
    </div>

    <div class="floatleft" style="padding: 14px;">
        <div class="rounded headerbox">
            <h1>INDI Journal Paper</h1>
            <p>Overivew of INDI and ProtoSD.</p>
        </div>
    </div>
</div>

<div class="clear"></div>

<div class="container">

<div class="innerpage">
<div class="p"><!----></div>

<div class="p"><!----></div>

<title>DNS Messaging for Service Discovery in Infrastructureless Mobile Networks</title>

<h1 align="center">DNS Messaging for Service Discovery in Infrastructureless Mobile Networks </h1>

<div class="p"><!----></div>

<div class="p"><!----></div>

<h3 align="center">Joe Macker </h3>

<div class="p"><!----></div>

<h3 align="center">Ian Taylor </h3>

<div class="p"><!----></div>

<h3 align="center">Naval Research Lab, Washington DC, USA </h3>

<h3 align="center">School of Computer Science, Cardiff University, Cardiff, UK </h3>

<div class="p"><!----></div>

<h2> Abstract</h2>
Service discovery is an important aspect of any automated distributed system and the more transient the distributed system's entities, the more problematic is this task.  In mobile ad-hoc networks (MANETs), where self-configuring infrastructureless networks of mobile devices are often connected by multi-hop wireless links, the challenge becomes significant with incongruous tradeoffs between state maintenance for reliability and bandwidth consumption for efficiency.  Potential solutions require techniques that can efficiently map the distributed application across a complexity of variable mobility patterns and underlying routing algorithms.  Existing standardized solutions for service discovery, such as mDNS, are inadequate because they employ a rather fixed set of timers that cannot adapt to different application scenarios and dynamics of the underlying network connectivity.   In this paper, we explore a combinatory approach that, on the one hand, leverages existing standardized service discovery messaging to ensure interoperability with mDNS and DNS, and then on the other,  provides flexible tuning of distributed modes of operation to serve the application's needs for a particular type of network. We discuss the application usages of such an approach and describe how these techniques can provide a bridging infrastructure for interoperability between mobile and fixed network infrastructures.  We show that by using this flexibility of tuning modes, we can create a proactive approach to service discovery, which we hypothesise can exhibit considerable efficiency and success rate gains over conventional techniques in transient mobile environments. We empirically prove this hypothesis by presenting results based on 96 different scenarios recorded using emulations representing real-world experiments that compare this approach with mDNS.

<div class="p"><!----></div>

<div class="p"><!----></div>

<div class="p"><!----></div>
<a id="tth_sEc1"></a><h2>
    1&nbsp;&nbsp;Introduction</h2>
<a id="sec:introduction">
</a>
The emergence of Apple's Rendezvous for (now Bonjour) upon switching from SLP [] with the launch of Mac OS X 10.2 "Jaguar" in August 2002, initiated a number of activities for standardization of a zero configuration protocol called Multicast Domain Name Service (mDNS, [,]). Since then, mDNS has since gained probably the most widespread deployment across platforms of all of its predecessors.   Other systems, such as  the Service Location Protocol version 2 (SLPv2) [] and the Simple Service Discovery Protocol (SSDP) in Microsoft's Universal Plug n' Play (UPnP) standard [] are in use but have not gained quite as much impact.

<div class="p"><!----></div>
For wide area networks, service discovery has taken a somewhat simplified or application-specific  approach. Middleware systems such as  JINI [] and Jxta [] and SOA-based architectures such as UDDI directories [], are based on simple mechanisms, supporting only basic multicast and/or unicast primitives for connecting to lookup servers, rendezvous nodes, and so forth. Most other service discovery in this space, even for the highly distributed peer-to-peer variety, tend to function at an application specific level once a node has connected to the application overlay using TCP, e.g. Limewire [] and Gnutella [].  The connection to the network itself e.g., the discovery of a "Limewire peer", is typically achieved through a centralized server list of good candidates. Although distributed query overlays (using rendezvous nodes) and distributed hash tables (DHTs, e.g. []) take different approaches, they also tend to be application specific by partitioning the network into sub-areas based on application-specific criteria and content e.g. file content, namespaces and cryptography keys, and so on.

<div class="p"><!----></div>
A similar approach through the use of a unicast connection is taken by mDNS to connect to the WAN, however, this has the added advantage that it leverages existing infrastructure for connecting a mDNS responder to a deployed DNS server. Since DNS is already ubiquitous on the Internet, programmers are already familiar with its interfaces and can deploy service advertisements using the same data structures that DNS does for other records.  In terms of uptake, dynamic discovery on a LAN and interoperability with existing infrastructure on a WAN therefore, it can be agued that mDNS seems to be gaining traction to become the potential de facto mechanism for standardized service discovery.

<div class="p"><!----></div>
For mobile ad-hoc networks (MANETs), research of service discovery has received less focus and there is a lack of extensive deployment experience in these environments. The bulk of past MANET work has mainly focused on improving the underlying transport protocols and routing algorithms rather than examining distributed service components, middleware, and other upper layers of the network system stack. There is a clear gap therefore between the MANET low-level routing protocol implementations facilitating packet delivery across highly transient multi-hop networks, and the somewhat high-level service discovery mechanisms, designed for far less transient devices on LANs.  None of the aforementioned service discovery approaches therefore address the MANET environment effectively.   Furthermore, the timer settings in existing protocols are typically statically defined through the standardization of the protocol but this restricts the effectiveness when heterogeneity and the persistence of services is more dynamic.  Present solutions therefore, by design, do not expose mechanisms or interfaces for fine timers or operating modes to provide flexibility and therefore widespread deployment of these protocols in a MANET is currently unsuitable.

<div class="p"><!----></div>
In this paper, we attempt to bridge these areas by, on the one hand, providing suitable service discovery mechanisms for addressing the dynamic nature of a MANET environment and yet, on the other hand, expose service messages in a format that is interoperable with the existing LAN and WAN infrastructure provided by mDNS.   To accomplish this task we integrate our previous Independent Network Discovery System (INDI) algorithms [] into JmDNS via its timer interfaces for adapting functionality for the MANET environment. By leveraging existing mDNS messaging and communication, INDI remains interoperable across operating systems and applications e.g., Apple and Windows Bonjour<a href="#tthFtNtAAB" id="tthFrefAAB"><sup>1</sup></a> and Linux-based AVAHI<a href="#tthFtNtAAC" id="tthFrefAAC"><sup>2</sup></a>. Therefore, it can ease both the transition burden and the interoperation with fixed-infrastructure networks by providing a standardized means to interact with global service-based infrastructure.    This reduces the problem of interoperability and the need to provide a single point translation from the MANET to the enterprise by creating a homogeneous messaging infrastructure. All that is needed thereafter in order to bridge the networks in terms of service discovery is to provide simple lightweight repeaters to relay the messages between them.

<div class="p"><!----></div>
In this work therefore, we attempt to address a number of research objectives, such as:

<div class="p"><!----></div>

<ul>
    <li> Is it possible to comply with the messaging infrastructure of standardized infrastructure mDNS and DNS, to provide interoperability with the LAN and WAN environments and still meet the needs of a MANET?
        <div class="p"><!----></div>
    </li>

    <li> How can these diverse environments be combined to facilitate one service discovery layer that can bridge between these different infrastructures?
        <div class="p"><!----></div>
    </li>

    <li> What are the considerations for deploying a service infrastructure in a MANET?
        <div class="p"><!----></div>
    </li>

    <li> What are the tradeoffs for employing a more proactive announcement scheme and shorter time to live settings for addressing the dynamic connectivity of nodes in a MANET ?
        <div class="p"><!----></div>
    </li>

    <li> Does the mDNS service discovery approach perform more efficiently than a proactive scheme for a MANET environment?
        <div class="p"><!----></div>
    </li>

    <li> Does the mDNS service discovery approach have a lower overhead than using a more proactive scheme for a  MANET environment?
        <div class="p"><!----></div>
    </li>
</ul>

<div class="p"><!----></div>
We hypothesize that by layering decentralized and mobility tolerant service discovery solutions upon an existing mDNS software infrastructure, we can meet these constraints. We also hypothesize that such a hybrid system would significantly outperform the existing service discovery algorithms and timers employed within mDNS for use within a dynamic context.  This paper&nbsp;therefore describes the  research conducted in this space, building from previous results from MANET experiments, extracting requirements, and architecting, designing and integrating these techniques within an existing mDNS infrastructure.

<div class="p"><!----></div>
The rest of the paper&nbsp;is organized as follows. The next section provides some background into existing efforts for service discovery in a MANET context. Section  discusses INDI in depth, providing a requirements analysis, architecture, design,  and implementation for the mDNS based discovery system.  Section  gives the background for the experiment and discusses the CORE emulation environment that we used for the experiments.  In Section , we discuss the application environment we use to deploy INDI and give some examples of applications we have used it for.  The methodology for the experimental is summarized in Section , which provides  an explanation of the distributed entities, the tools used and the rational for the metrics.  Finally, in Section , we give the results from the experiment, providing a detail overview of overhead rates for each protocol, latencies and success rates that satisfy the quality of service metric defined in Section . The paper&nbsp;is concluded in Section

<div class="p"><!----></div>
<a id="tth_sEc2"></a><h2>
    2&nbsp;&nbsp;Background</h2>
<a id="sec:background">
</a>
INDI is designed to provide robust service discovery in the Mobile Ad-hoc network (MANET) environment [,,], which has historically been far more focused on the development and testing of unicast routing protocols, and to a lesser extent, multicast routing and forwarding  [,,]. Even so, there are now many approaches to MANET routing and architectures and daily operational experience has been gained in their use e.g., operational community networks [].  However, far less research is focused on generic collaborative applications e.g. multiuser chat [], operating in such networks, and in particular, service discovery overlays to help automate group communications.

<div class="p"><!----></div>
Highly scalable existing systems, such as some peer-to-peer systems (Gnutella, Limewire) and distributed hashtables (e.g. CAN [], Chord []) for a WAN, tend to address transient connectivity through redundancy, providing multiple paths across the virtual overlay to provide resilience in the event of nodes leaving the network. Although such approaches works well for Internet applications, it has a large traffic overhead (through partial flooding) in terms of traffic and is not easily translated to a  environment that is more restricted in terms of bandwidth.

<div class="p"><!----></div>
For service discovery, there are number of approaches e.g, the aforementioned SSDP, mDNS, Bonjour and SLP, and many  have undergone an extensive standardization effort with a tight focus on the deployment environment that they address.  For the case of mDNS, it focuses on use with a site local LAN and provides interoperability with existing DNS servers for a WAN.  Therefore, the system is tuned specifically for this context with underlying timers being rigidly defined. Furthermore, mDNS also attempts to provide a single operational protocol to cover all use cases within a LAN and so it employs a rather generic combination of reactive and proactive service discovery schemes that work in tandem. This approach by definition requires more redundancy to provide the robustness and genericness requirements for a LAN, which inevitably leads to a higher overhead in communication.

<div class="p"><!----></div>
The extra message overhead associated with such an approach is generally unacceptable for a MANET, which typically has a far more restricted bandwidth. We will show the bandwidth connotations of this in Section  and we will also see that more specifically tuned deployments may well be more suited to the underlying mobility patterns of a network at a point in time e.g. employing more proactive-based schemes may suit more dynamic networks.  This is not a criticism of the of the mDNS approach at all because it designed specifically to address the needs of the LAN environment and to provide a fault tolerant and safe solution within that intended infrastructure.   One cannot design a single protocol to address all possible environments and in this paper, we argue this point strongly.

<div class="p"><!----></div>
In our work here therefore, we intentionally take a more hands off approach and instead provide a concise but functional set of parameters and profiles that can be used to apply the mDNS-style infrastructure in multiple ways depending on the needs of the application and the underlying mobility patterns.    We hope that this work might form a reasonable starting point for a taxonomy for addressing this space in future.      There is currently a complimentary early draft effort on-going within the IETF for Extended mDNS (xmDNS,  []), which aims to  extend mDNS to site-local scope. Although this approach makes steps in defining a multicast address to accommodate site-scoped support of mDNS, it does not provide profiles and timing settings for such deployments and therefore we believe the work described in this paper&nbsp;has a complimentary focus.

<div class="p"><!----></div>
<a id="tth_sEc3"></a><h2>
    3&nbsp;&nbsp;INDI</h2>
<a id="sec:indi">
</a>
Previously, we have published results to show that different combinations of service providers and consumers led to significantly different service requirements within a MANET environment []. This led to a prototype implementation of our Independent Network Discovery Interface (INDI) that addressed these concerns by providing three different profiles and flexible configuration parameters for applying bespoke timers and multicast distribution policies for these different mobile scenarios. We later discussed the adaptation of this implementation to work alongside mDNS to address the MANET architectural considerations and for maintaining full interoperability with existing mDNS enterprise deployments (e.g. Apple Bonjour, etc) []. We also provided a functional empirical analysis of JmDNS, Bonjour and INDI mDNS when discovering single services on a LAN and showed that  INDI can have up to a twelvefold reduction in network messages over these existing protocols when discovering a single service on a LAN mainly because of the generic nature of the mDNS discovery scheme, described in the previous section.

<div class="p"><!----></div>
By integrating INDI profiles on an existing mDNS infrastructure we aim to be able to offer robust service discovery mechanisms for use within a MANET and at the same time, remain interoperable with existing fixed infrastructure service discovery solutions, which will make it easier to integrate with existing applications. To achieve this, the underlying structure for an mDNS message needs to be understood as well as the the algorithm that mDNS employs to perform service discovery on a LAN.  By extracting these requirements, we will override the timers of these components and overlay modes in order for the same stack to operate using the new profiles and timers tuned for a MANET.  In the next section, we look at the structure mDNS in order to extract such requirements.

<div class="p"><!----></div>
<a id="tth_sEc3.1"></a><h3>
    3.1&nbsp;&nbsp;Requirements from mDNS</h3>
<a id="sec:requirements">
</a>

<div class="p"><!----></div>
An mDNS network comprises a number of mDNS responders (or Bonjour services), which implement the Multicast DNS specification for advertising and discovering mDNS services.  An mDNS responder uses link-local IP Multicast on UDP port 5353 for transmission and can optionally connect to a unicast DNS for service discovery anywhere in the world. mDNS uses DNS resource record data types provided in table , which allow both host resources and services to be specified. Records can also use the DNS wildcard resource record (ANY) for matching  thereby enabling the ability to browse the network.  An mDNS formatted message contains a header, a question, answer, authority, and additional record sections, as shown in the "mDNS Message" section in Figure .   A given DNS record is capable of answering a DNS question if the record name matches the question name, the record <em>rrtype</em> matches the question  <em>qtype</em> (or the <em> qtype</em> is "ANY" (255) or the  <em>rrtype</em> is "CNAME" (5)) and the record  <em> rrclass</em> matches the question  <em>qclass</em> (unless the  <em>qclass</em> is "ANY" (255)).

<div class="p"><!----></div>
<span class="footnotesize">

<div class="p"><!----></div>
<a id="tth_tAb1">
</a> <div style="text-align:center">Table 1: DNS resource records used by mDNS</div>
<a id="table:resource:record">
</a>

<div style="text-align:center">

    <table border="1">
        <tr><td align="center"><b>Resource Record</b> </td><td align="center"><b>Abbr.</b> </td><td width="296"><b>Description</b></td></tr>
        <tr><td align="center">Addressing </td><td align="center">A </td><td width="296">Specify the IPV4 address of this host and are used to resolve IP addresses (see []).</td></tr>
        <tr><td align="center">IPV6 Address </td><td align="center">AAAA </td><td width="296">Specify the IPV6 128-bit host address [].</td></tr><tr><td></td></tr>
        <tr><td align="center">Text  </td><td align="center">TXT </td><td width="296">Specifies multiple strings of text, up to 255 characters long []. </td></tr>
        <tr><td align="center">Wildcard  </td><td align="center">ANY </td><td width="296">Specifies a wildcard to match any number of labels in a name []. </td></tr></table>

</div>

<div class="p"><!----></div>
<div class="normalsize">All mDNS packets contain an IP time to live (IP TTL) in the header for the hop-count limit (for link local, this should be 255 to indicate no forwarding).   An mDNS resource record also contains a RR TTL,  used to specify the  number of seconds for which the record may be cached.   The recommended TTL value for Multicast DNS with a host name as the resource record's name (e.g. A, AAAA, HINFO, etc.) or a host name contained within the resource  record's  <em>rdata</em> (e.g. SRV, reverse mapping PTR record, etc.) is 120 minutes.   Other mDNS resource records have a TTL of 75 minutes.

<div class="p"><!----></div>
Upon bootstrapping (start up, wake up from sleep, or that its network connectivity has changed), a mDNS responder performs two operations:

<div class="p"><!----></div>

<ul>
    <li> <b>Probing:</b>  three probes are sent onto the network, 1 second apart.  Probes query any of the resource records that desire to be unique on the local link are not already in use.  The primary use of this is to resolve a host's address record (A or AAAA) and identify address conflicts to map the unique host name to its unique IPv4 and/or IPv6 address.  Probe queries set the desired resource record name, class and query type to "ANY" (255), allowing a single question to be used in place of several questions. The probe queries also can contain service adverts that this mDNS responder is responsible for once the mDNS responder has announced itself on the network. In effect therefore, each message can contain a host record and/or several service records.
        <div class="p"><!----></div>
    </li>

    <li>   <b>Announcing:</b>  two announcements  are sent onto the network at 250 milliseconds intervals once probing has finished, regardless of operating role (i.e. server or client).  The announcer then sends the lists of service adverts it is responsible for once onto the network to advertise the list of services it has available to other users.
        <div class="p"><!----></div>
    </li>
</ul>

<div class="p"><!----></div>
The mDNS protocol first discovers abstract advertisements and then only resolves its endpoint when the client wishes to make use of it.  In the meantime, its address can change if a laptop moves IP address for example. Therefore, for client-side resolving of adverts, there are three resolvers that are used to query certain levels of service abstractions, as follows:

<div class="p"><!----></div>

<ul>
    <li> <b>Type Resolvers:</b>  that query the network for service types e.g. _http._local.
        <div class="p"><!----></div>
    </li>

    <li> <b>Service Resolvers:</b> that query for services of a given a specific name and type.
        <div class="p"><!----></div>
    </li>

    <li> <b>Service Info Resolvers:</b> that resolve the address for a service, given its name.
        <div class="p"><!----></div>
    </li>
</ul>

<div class="p"><!----></div>
Each resolver queries the network three times at 225 millisecond intervals.  A client then goes into probing mode, making three 1 second interval queries and then onto the announcer for two further queries.  After announcing has finished, the client can be considered initialized and can starting resolving services.     The client attaches itself as a listener to asynchronously discover services through notification.  Two service resolvers are set up by JmDNS: the first listens for any occurrences of the service name, converted to lower case, and the second for the name provided as is.

<div class="p"><!----></div>
Therefore, from a protocol perspective, there are five entities that control the algorithm that mDNS uses to exchange messages at particular intervals between mDNS responders.  These entities form the foundation for the resulting architecture, design and implementation of INDI mDNS, which is described in the following sections.

<div class="p"><!----></div>
<a id="tth_sEc3.2"></a><h3>
    3.2&nbsp;&nbsp;Architecture and Design</h3>
<a id="sec:architecture-design">
</a>

<div class="p"><!----></div>
In the previous section, the mDNS requirements have been provided.  Through the aforementioned previous experiments [] covering several hundred simulations across a broad range of service discovery schemes (reactive and proactive), we found that the following parameters were required in order to meet the design needs for the range of applications we are interested in:

<div class="p"><!----></div>

<ul>
    <li>  <b>AdvertLifetime:</b> lifetime (TTL) that the service. For JmDNS, this is fixed but in INDI, this can be adjusted for the particular application.
        <div class="p"><!----></div>
    </li>

    <li>  <b>ReadvertisementInterval:</b> interval that providers proactively send out service advertisements onto the network e.g. a service provider can periodically send out its advertisements every 5 seconds.
        <div class="p"><!----></div>
    </li>

    <li>  <b>NumReadvertisements:</b>  number of times to readvertise the service or you can set this value to -1, which means advertise forever.
        <div class="p"><!----></div>
    </li>

    <li>  <b>ClientQueryIntervals:</b>   are the times at which a client sends out queries for services onto the network and is
        specified for flexibility using a <em>timeouts</em> array of absolute millisecond times for sending out a query, e.g. 0, 100, 200, 400, 800, would send queries at 0, 100, 200, 400 and 800 milliseconds.
        <div class="p"><!----></div>
    </li>

    <li>  <b>ServiceCancelInterval:</b>  specifies the interval at which to send proactive service cancel notifications. A cancell message can be used to notify distributed mDNS peers that an advert should be deleted.
        <div class="p"><!----></div>
    </li>

    <li>  <b>NumServiceCancelMessages:</b>  number of times to send proactive service cancelled packets.
        <div class="p"><!----></div>
    </li>

    <li> <b>Port:</b>  port to send messages (default is mDNS, 5353)
        <div class="p"><!----></div>
    </li>

    <li> <b>Send Wait Interval (OppCache):</b> offset interval before switching to reactive mode. This enables a wait time for a client to listen for proactive advertisements before entering into a query phase.
        <div class="p"><!----></div>
    </li>
</ul>

<div class="p"><!----></div>
Collectively, these parameters can be used to implement a number of different modes and message exchanges.  Parameters can be set to approximate mDNS behavior using a combination of reactive and proactive timer setting but cannot be configured to replicate mDNS exactly.  However, for a MANET, we can group combinations of these parameters to form three broad INDI modes (setting profiles) for simpler use:  <b>Reactive:</b> where the consumer dispatches a service request using a query and providers respond with a service advert (i.e. the Responder in Figure  ); <b>Proactive:</b> where the providers perform a service push by periodically sending out their service adverts using multicast;  and <b>Opportunistic Caching:</b>  is based on the concept that if a consumer queries for a service, other consumers may be interested in that service i.e. we opportunistically cache for future use.  The three profiles therefore need to be layered onto the entities described in Section <a href="#sec:requirements">3.1</a> to form the basis for the implementation of INDI, whilst retaining the underlying interoperability of mDNS messages.

<div class="p"><!----></div>

<div class="p"><!----></div>
<a id="tth_fIg1">
</a> <div style="text-align:center">
    <a href="INDIArchitecture.png"><img src="INDIArchitecture.png" alt=""></a>

    <div style="text-align:center">Figure 1: INDI Architecture</div> <a id="indi:fig:architecture">
</a>
</div>
<div class="p"><!----></div>
Figure  <a href="#indi:fig:architecture">1</a> shows the resulting architecture for INDI taking into consideration the INDI design specification and the mDNS entities used to implement the mDNS functionality.  This architecture shows a schematic for the layering of the INDI design profiles: reactive; opportunistic cache; and proactive, onto the existing advertiser and responder, type, service, info resolvers.     It can be seen that for the client side, JmDNS entities are similar to INDI, the major differences being in the number of resolvers deployed and the timings of retries to support the INDI design configurations.  However, the server side protocol is significantly different with INDI only requiring advertising and responding roles compared with JmDNS that has probe, announce, responder and renew roles.  The advertising role in INDI is a simplification of the probe, announce and renew roles in mDNS.

<div class="p"><!----></div>
The rest of the software architecture mimics JmDNS as illustrated in Figure  <a href="#indi:fig:architecture">1</a>. Once packaged by the different entities, the message format can use the same messaging serializer and on-the-wire format to remain compatible with DNS.  INDI therefore should be 100% JmDNS/mDNS, AVAHI and Bonjour interoperable.

<div class="p"><!----></div>
For the networking level, the conventional deployment of JmDNS and INDI differs considerably. Whilst on a static infrastructure LAN, the protocols being used would be standard multicast and unicast, on a MANET, these underlying protocols would generally be replaced by more flexible and adaptive protocols to cope with the changing infrastructure more effectively. An issue that impacts critically here, is the link-local scoping of  mDNS that forms part of the specification.   Therefore, since mDNS is intended for link local operation and there are presently no de facto standards or accepted addressing practices for extensions to site-local or multi-hop ad hoc network operation, we also support "proof-of-concept" multi-hop operation through a SMF (Simple Multicast Forwarding) [] plugin, which forwards mDNS messages for site-scoped  areas, where mobile ad hoc routing may require highly dynamic edge routing.  This solution provides an administratively scoped multi-hop capability versus the more typical single network hop IP link-local multicast capability used by many deployed service discovery approaches.

<div class="p"><!----></div>
These same types of optimized flooding algorithms are also available in many ad hoc routing control planes and existing research has demonstrated the ability to encapsulate service discovery messaging within the control plane mechanism []. We do not suggest a particular approach to the message forwarding here, as there are many valid options and INDI supports standard IP multicast traffic that can also be adapted for middleware encapsulation.  Rather, we focus on examining the use of such techniques, whether encapsulated or not, to enable the potential for more robust distributed querying, response, and proactive notification.

<div class="p"><!----></div>

<div class="p"><!----></div>
<a id="tth_sEc3.3"></a><h3>
    3.3&nbsp;&nbsp;Implementation</h3>
<a id="sec:implementation">
</a>

<div class="p"><!----></div>
We have been working closely with the JmDNS community [] provide a pluggable architecture in JmDNS for INDI to be able to provide different functionality for the mDNS entities described in Section <a href="#sec:requirements">3.1</a> for overlaying INDI profiles (see Section <a href="#sec:architecture-design">3.2</a>).  The JmDNS [] authors provided customization of the Java timing interfaces to the JmDNS entities for our use to integrate custom tasks for layering INDI modes, which is shown in Figure  <a href="#indi:fig:architecture">1</a>.

<div class="p"><!----></div>
For the entities, we replace the <em>Prober</em>, <em>Announcer</em> and <em>Renew</em> tasks with an Advertiser class, which performs the proactive advertisements as and when they are required.  A and AAAA records are not included in the advertisements because in a MANET, other address mechanisms are in place to avoid potential conflicts here.  INDI includes a modified <em>Responder</em> for replying to tasks, which switches between unicast and multicast depending on the mode we are working within i.e. for Opportunistic cache and Proactive modes the responder replies with a multicast message and in Reactive, it replies with a unicast message.

<div class="p"><!----></div>
On the client side, the type, service and service info resolvers resemble the JmDNS variants with three main differences.   INDI resolvers always check the cache before sending out queries to the network.   Secondly, the sequence of solicitations for resolving queries is different.  A user can specify any sequence they choose in INDI so this is a user preference depending on the application.  Third, the responses from the resolver are far more aggressively propagated to the resolvers in INDI.  This results in less queries being sent because as soon as a reply to a query has been received, the resolver quits operation.

<div class="p"><!----></div>
There are other housekeeping classes that differ in the INDI implementation.    We have the INDI <em>Canceller</em> that can be customized to send out packets onto the network at whatever interval a user chooses or can be turned off to act in a completely passive manner and allow the TTL to expire the advertisement.  For example, for the experiments in Section , we do not send any cancel messages onto the network because the TTL is so short we do not need further proactive behavior from the other components.  Instead, we use the INDI <em>RecordReaper</em>, which is far more aggressive than the JmDNS counterpart.  Reaper intervals can be specified in the configuration depending on the frequency one would like to check the cache and expunge out of date advertisements.  For JmDNS, this is generally performed to coincide with other requests but in INDI one can program it to check at the millisecond level.   For the experiment described in  Section , we use a reaper interval of 500 milliseconds.

<div class="p"><!----></div>
INDI provides a profile structure that build up layers according to the profiles defined through combinations of the core parameters defined in the previous section.  The Java class <em>Profile</em> provides rudimentary defaults for all modes.   Client query intervals (for the resolver implementations) are set to trigger at 0, 100, 200, 400, 800 and 1600 milliseconds, respectively. The default TTL is set to the the mDNS specification recommended value of 2 hours and the readvertisement interval is set to half that value, also as recommended in the specification.  These defaults are inherited  by the <em>Reactive</em> class, which exhibits the most similar behavior to mDNS.   The <em>Opportunistic Cache</em>  profile also inherits the same behavior as <em>Reactive</em> but it differs in that it responds to queries using multicast so that other INDI nodes can opportunistically cache the results. It also differs in that it does not proactively request a service until it first checks its cache to see if one that matches has already been cached (by using the Send Wait Interval).

<div class="p"><!----></div>
The <em>Proactive</em> profile, on the other hand, is significantly different.  First, the TTL value is generally a lot shorter.   For the experiments, we describe in Section , we use a TTL of 2 seconds and a readvertisement interval of 1 second.   Second, the endpoints are always included in the proactive announcements because the readvertisement rate is so high that the endpoints are constantly refreshed anyway. Therefore the resolvers generally are never need to send out resolver queries, so the sequence of resolver timeouts is changed to make sure the cache is checked before any resolving sequence takes place.

<div class="p"><!----></div>
<a id="tth_sEc4"></a><h2>
    4&nbsp;&nbsp;Experiment Background and Emulation Environment</h2>
<a id="sec:core">
</a>
In the experiments discussed in this paper, we expand on previous experiments, described in Section <a href="#sec:indi">3</a>, by applying JmDNS and INDI to a full emulated scenario that is designed to empirically measure the differences in message overhead and latency for a realistic scenario.  Therefore, for the experimental evaluation in comparing the performance of INDI and JmDNS, described in  and , we used the CORE Emulation framework [].

<div class="p"><!----></div>
The Common Open Research Emulator (CORE)  is a network emulator that runs real computer networks in real time.  This is quite distinct from  simulation (e.g. ns-2 []), which builds a model of a real network and then triggers events at discrete time intervals in order to simulate a actual application's use of that network.    Although simulators can be used to provide targeted empirical evaluations, generally most experiments are limited in scope and provide very focused and controlled experiments which make a number of functional assumptions compared to what a real application might do.   Therefore, the deployment of such applications in real-world environments can often be problematic and lead to a number of unmeasured issues and bugs that are caused by both the application's software implementation (code issues, multi-threading, socket performance, etc) and underlying network problems that can significantly affect performance.  Consequently, and timely due to the growth and maturity of lightweight virtual machine implementations, we have chosen to use the CORE emulation environment for our INDI experiments, in order to to gather real-world deployment experience for moving to production quality more expeditiously.

<div class="p"><!----></div>
Briefly, CORE has two components:  a CORE services (daemon), which manages the emulation sessions and interfaces with the underlying Kernal virtualization; and the graphical user interface, which is a drag and drop GUI that can be used to orchestrate the creation of the nodes. These two components communicate using an asynchronous, sockets-based CORE API, which is written in Python.

<div class="p"><!----></div>
The Core services daemon, on Ubuntu 11.04, interfaces with Linux network namespaces virtualization to build its virtual nodes. Linux namespaces builds up from chroot to implement complete virtual systems, adding resource management and isolation mechanisms to the existing process management infrastructure.  The result is that each node is a lightweight virtual system with full resource isolation and resource control for an application; that is, each node essentially provides a lightweight virtual machine, which can all access a common host filesystem (although permissions can be set so that some directories are private on a per-container basis).  Linux network namespaces (netns) is part of the mainline 2.6.27+ Linux kernel.

<div class="p"><!----></div>
From a network perspective,  each namespace has its own loopback device and process space. Virtual or real devices can be added to each network namespace, and you can assign IP addresses to these devices and use them as a network node.  The virtual networks are built using the Linux Ethernet bridging and for the Wireless implementation we use here, employ the use of OSPF routing protocol configurations  using the Quagga [] open source routing suite.  The MDR router type in CORE builds OSPF MANET Designated Routers (MDR) configurations which requires a modified version of Quagga [].   Quagga OSPFv3 is such an implementation of  OSPF MDR [],  OSPF Database Exchange Optimization [], and  OSPFv3 Address Families [], for efficient routing in mobile ad hoc networks (MANETs).

<div class="p"><!----></div>
<a id="tth_sEc5"></a><h2>
    5&nbsp;&nbsp;Service Visualization</h2>
<a id="sec:protosd">
</a>
The INDI discovery systems is currently being used for chat and multimedia applications in the Naval Research Lab [,].  It provides low level modes for service discovery in mobile networked environments and provides interfaces for allowing applications to use this functionality to enable end-to-end connectivity.  In this section, we describe ProtoSD, which is the operating and service visualization environment for INDI and outline some of the applications that are INDI is motivated by.

<div class="p"><!----></div>
Proto Service Discovery (ProtoSD) is a toolkit that provides a single homogeneous toolkit for running both the mDNS and INDI discovery systems.   ProtoSD has a: command-line interface modeled using Apple's "mdns" command line tool for Bonjour; file-based interface for allowing third party applications to be integrated; and a Web-based interface for dynamic visual representation of the discovered services through a conventional Web browser.   The file interface and Web interface are the two most commonly used.  For the file interface, ProtoSD can optionally be used to generate ".services" files,  providing a simple file-based API for other applications to interface with e.g. we are currently using this with Python to read the ".services" file and provide a TV channel for incoming videos.  It also allows a single sink application to read services from multiple sources on a shared file system, which enables service browsing in CORE .  Our two main usages therefore are:

<div class="p"><!----></div>

<dl>
    <dt><b>Private Service Browser:</b></dt>
    <dd> by running the ProtoSD Web component locally and  browsing the network using the command line with a "-g" flag, ProtoSD enables the back-end Web server to provide a dynamic updated view of the services.</dd>
    <dt><b>CORE Service Browser:</b></dt>
    <dd> using CORE's shared file system, it is possible to use ProtoSD to show the services being discovered on all CORE nodes simultaneously using one browser.</dd>
</dl>

<div class="p"><!----></div>
For private browsing, ProtoSD passes service discovery and removal announcements directly to the command line or Web browser component for visualization, whilst for CORE, the ProtoSD file interface is used to bridge between CORE and the host Web browser.    Each CORE node stores its discovered services  in "/tmp" within ".services" files (named after their node name and network interface). The host scans this directory for write updates and loads all files simultaneously for rendering in a Web browser. Since the CORE nodes are not easily connected to the host, this simple shared file based mechanism provides a convenient way of visualizing the services without needing to reconfigure the default set up of CORE.   Using this approach, one can give a global view the services dynamically as and when services are advertised and removed from the network.  All of the emulations described in Section  used ProtoSD to visualize the output as the emulations were taking place.  This also provides a quick-look verification mechanism for ensuring the runs were operating normally and thus expedited the process.

<div class="p"><!----></div>

<div class="p"><!----></div>
<a id="tth_fIg2">
</a> <div style="text-align:center"><a href="ProtoSDCore.png"><img src="ProtoSDCore.png" width="800px" alt=""></a>

    <div style="text-align:center">Figure 2: ProtoSD running in CORE showing the services discovered during one mobile emulation for the INDI discovery system.</div>
    <a id="indi:protosdcore">
    </a>
</div>
<div class="p"><!----></div>
On the right hand side of Figure <a href="#indi:protosdcore">2</a>, we show a screenshot of the ProtoSD Web interface, displaying the services it has discovered from each consumer in a CORE emulation in a tree view.  ProtoSD uses a Java-based lightweight Web server framework, called Restless<a href="#tthFtNtAAD" id="tthFrefAAD"><sup>3</sup></a>, for exposing the backend services.   Restless is a simple HTTP 1.0 compliant Web server that is capable of delivery multiple types of data efficiently and providers virtual endpoints for representing services using REST facilitating the Create, Read, Update and Delete (CRUD) style of operations.  To enable dynamic updates, ProtoSD uses a client-side JQuery component <a href="#tthFtNtAAE" id="tthFrefAAE"><sup>4</sup></a>  that queries the server using an AJAX asynchronous HTTP GET to return service advertisement updates as and when new services are available. In this way, the browser updates immediately upon discovery of a new service (i.e. uses the COMET style<a href="#tthFtNtAAF" id="tthFrefAAF"><sup>5</sup></a> of server callback). By exposing two independent endpoints for fetching a JSON or HTML data structure from the server, it can render  using either a JsTree<a href="#tthFtNtAAG" id="tthFrefAAG"><sup>6</sup></a> JQuery tree structure or HTML, for displaying to the users. Using the "search" textfield at the top right allows pruning of this list to match only the provided string.

<div class="p"><!----></div>

<div class="p"><!----></div>
<a id="tth_fIg3">
</a> <div style="text-align:center"><a href="ProtoSD.png"><img src="ProtoSD.png" alt=""></a>

    <div style="text-align:center">Figure 3: An overview of ProtoSD showing the interfaces by which services are advertised and how services can be discovered and visualized.   We also show the kinds of applications ProtoSD has already been implemented with.</div>
    <a id="indi:protosd">
    </a>
</div>
<div class="p"><!----></div>
Figure <a href="#indi:protosd">3</a> shows an overview of the various components involved in advertising and discovering using ProtoSD and some of the application use cases.   ProtoSD has been used as a private browser for discovering multimedia (video and audio) streams and providing an interface for allowing clients to connect to them using video toolkits (e.g. VLC<a href="#tthFtNtAAH" id="tthFrefAAH"><sup>7</sup></a>).  For some applications, the Web GUI also provides an off-the-shelf solution for exposing management information about the participants in the network.  For example, for an XMPP multi-user chat (MUC) session, the ProtoSD browser can be used to provide a similar mechanism to what centralized XMPP management servers provide for administrators. Using OpenFire<a href="#tthFtNtAAI" id="tthFrefAAI"><sup>8</sup></a>, an administrator can view the current MUC rooms created by users that are currently connected to this server.   For ProtoSD, the MUC rooms that are created by its users also appear as adverts on the multicast network and are consequently discovered by ProtoSD and listed through the Web GUI accordingly.  ProtoSD and INDI have already been used for this purpose by integrating with the XOP[] serverless XMPP chat system on a MANET.

<div class="p"><!----></div>
<a id="tth_sEc6"></a><h2>
    6&nbsp;&nbsp;Experiment Methodology</h2>
<a id="sec:methodology">
</a>

All experiments performed in this paper&nbsp;were running CORE, described in Section <a href="#sec:core">4</a>, on an Ubuntu 11.04 virtual machine hosted using VMware Fusion on a Mac Air laptop. The experiment emulates a 10 node wireless networking mobile scenario, which consists of 9 consumers (nodes that want to discover a particular service) and 1 producer (a node that wants to advertise a service for use by others).   The mobility patterns for this scenario were generated using an ns-2 mobility pattern generator and then imported into CORE using its inbuilt ns-2 mobile script importer. The emulation runs for 250 seconds and for mobility purposes, the nodes where split into two distinct groups with 5 nodes per group: the first group containing consumers 1-4 and the producer; and the second containing consumers 5-9 inclusively. A screenshot from the CORE GUI representation of this scenario is provide in Figure . The mobile network has a range of 200 meters and a bandwidth of 54 MHz and the entire surface for the emulation covered a surface of  330,000 square meters (600 x 550) with a maximum speed of each node being 20 meters per second. The two clusters of 5 nodes fragment and coalesce around every 30 seconds and therefore there are 4 fragmentations, where the two groups go out of range from each other, during the entirety of the emulation.  This is discussed further in the next section.

<div class="p"><!----></div>

<div class="p"><!----></div>
<a id="tth_fIg4">
</a> <div style="text-align:center"><a href="COREEmulation.png"><img src="COREEmulation.png" alt=""></a>

    <div style="text-align:center">Figure 4: The running CORE Emulation showing 9 clients and one service running INDI</div>
    <a id="indi:fig:core">
    </a>
</div>
<div class="p"><!----></div>
<a id="tth_sEc6.1"></a><h3>
    6.1&nbsp;&nbsp;Data Collection</h3>

<div class="p"><!----></div>
To collect data from the live emulation experiments, we implemented a distributed file-based event mechanism that gathers information about the low-level packets alongside the higher-level discovery events for each CORE node in a consistent fashion and common format.  Data is collected using one line per event and stored as Comma Separated Values (CSV) for quick-look analysis in Excel and convenient post processing using Java and bash scripts. The CSV files from all CORE nodes are collected in "tmp/protosd-current" and time is synchronized across all nodes, which is triggered by the pressing of "Play"  for initialing the mobility pattern in CORE. This ensures the timing consistency between multiple runs. We record three levels of events:

<div class="p"><!----></div>

<dl>
    <dt><b>At the Packet Level: </b></dt>
    <dd> Packet level events are measured using a Java "tcpdump" unix process on every core node that records all packets transmitted on the mDNS multicast address (224.0.0.251) on "eth0", which is the wireless interface on each CORE node on the emulation.    Packet events store the core node the packet was measured on, the message identifier and its length (in bytes).   The packet level events are used to record the traffic across the course of the emulation in order to construct traffic histograms showing the traffic  at each time-step of the experiment.</dd>
    <dt><b>At the Discovery Level: </b></dt>
    <dd> Discovery level events record the arrival and departure of services during the course of the emulation.  Service events are recorded from a service producer (when an advert is advertised and removed) and from a consumer (when an advert is resolved and removed)</dd>
    <dt><b>Multicast Pings: </b></dt>
    <dd> In order to automatically detect the mobility pattern during the course of the emulation, we first observe (as a separate run) multicast ping events.  The "multicast ping" does not follow the ping protocol but offers a similar level of functionality by sending out packets that can be used to detect whether a server is reachable or not at any given point of time.  In the case of multicast and the one-to-many relationship, we send a multicast message from the producer node to the mDNS multicast address.  All consumers join this multicast group and listen for responses.</dd>
</dl>

<div class="p"><!----></div>

<div class="p"><!----></div>
<a id="tth_fIg5">
</a> <div style="text-align:center"><a href="indi10ping-distribution.png"><img src="indi10ping-distribution.png" alt=""></a>

    <div style="text-align:center">Figure 5: The connectivity of the two groups of nodes during the course of the 250 second emulation.  The nodes fluctuate between 9
        consumers and 4 consumers when the two groups split.</div>
    <a id="indi:fig:emulationconnectivity">
    </a>
</div>
<div class="p"><!----></div>
Multicast ping messages are sent out 10 times per second and we record the event as and when they are received by each consumer to record when each consumer is reachable from the producer.  Ping packets contain an identifier (a simple incremental counter from the producer) along with the sender name. The multicast ping events provide us with a 100 millisecond connectivity matrix for the entire duration of the emulation, which is extremely important, as it allows us to calculate a theoretical limit for the optimal success rates that should be achievable by the service discovery systems.  The result of the ping events can be seen in detail in Figure <a href="#indi:fig:emulationconnectivity">5</a> for the mobility pattern we used in the emulations.  Multicast ping events are used to generate a histogram that shows the number of consumers that are "connected"<a href="#tthFtNtAAJ" id="tthFrefAAJ"><sup>9</sup></a> to the producer at a particular point in time. Therefore, Figure <a href="#indi:fig:emulationconnectivity">5</a> shows that the number of consumers that are within a multi-hop reachable path of the producer fluctuates between 9 and 4 nodes at the times shown by the X axis of this figure.   This reflects the two distinct groups and the points in the graph where only 4 nodes are connected represents a fragmentation of the two groups.  Therefore, there are 8 transitions during the emulation where the two groups of nodes fragment and then rejoin.

<div class="p"><!----></div>
<a id="tth_sEc6.2"></a><h3>
    6.2&nbsp;&nbsp;Service Advertisements and Qualitative and Quantitative Metrics</h3>

<div class="p"><!----></div>
To measure the responsiveness of the service discovery system for detecting the arrival and departure of services in the face of network fragmentation and dynamics, we generate a sequence of finite-length service advertisements during the course of the emulation.  The adverts are sequentially numbered in chronological order and are named  according to the discovery system that is being used for a particular test (e.g. INDI or mDNS).   For terminology, each advert "arrives" in the network when it is advertised and "departs" from the network when that service advertisement is removed.    Services are sequenced according to a Poisson distribution and split into three sets with a mean interval of 10, 20 and 30 seconds.  When one advert is advertised the previous advert is simultaneously removed.

<div class="p"><!----></div>

<div class="p"><!----></div>
<a id="tth_fIg6">
</a> <div style="text-align:center"><a href="indi10advert-distribution.png"><img src="indi10advert-distribution.png" alt=""></a>

    <div style="text-align:center">Figure 6: Shows the time and duration (x axis) that each of the named services (y axis) are advertised for during the emulation.</div>
    <a id="indi:fig:poisson-10-adverts">
    </a>
</div>
<div class="p"><!----></div>
A pictorial representation of the time and duration of services advertised in an emulation, with a Poisson mean interval of 10 seconds, is provided in Figure <a href="#indi:fig:poisson-10-adverts">6</a>. This diagram shows the emulation time (in seconds) on the x-axis and the name of each service advertised, sequenced by service name and hence arrival time, on the y axis.  In this particular emulation therefore, there are 27 service advertisements during the 250 second emulation, which exhibit Poisson behavior with respect to the time duration they are advertise for.

<div class="p"><!----></div>
In a Poisson exponential probability distribution, the time interval from the current time to the occurrence of the next event does not depending upon the time of occurrence of the last event. This provides a somewhat realistic distribution for modeling real-world random events, such as the arrival of service advertisements in a number of application scenarios. For the same reason, Poisson is often used to model customer arrivals that trigger requests for stress testing web servers.

<div class="p"><!----></div>

<div class="p"><!----></div>
<a id="tth_fIg7">
</a> <div style="text-align:center"><a href="indi10advert-distribution-fragmented.png"><img src="indi10advert-distribution-fragmented.png" alt=""></a>

    <div style="text-align:center">Figure 7: Shows the time and duration (x axis) that each of the named services (y axis) are available for to the fragmented nodes during the emulation.</div>
    <a id="indi:fig:poisson-10-adverts-frag">
    </a>
</div>
<div class="p"><!----></div>
Figure <a href="#indi:fig:poisson-10-adverts">6</a>  shows the service view from the producer side (server side), which although is also consistent with the permanently connected Consumers 1-4, does not show the consumer view for Consumers 5-9 - the group of consumers that get fragmented according to the distribution shown in Figure <a href="#indi:fig:emulationconnectivity">5</a>.  During times of fragmentation therefore, the possibility of discovering the advertisements becomes even more restricted and if we apply this connectivity matrix to the service distribution, we obtain Figure <a href="#indi:fig:poisson-10-adverts-frag">7</a> that illustrates the actual availability of services advertisements for nodes 5-9 after the fragmentation has been applied to the network.  As one can see, during the periods of fragmentation several adverts e.g. INDIService11, INDIService12, INDIService23 and INDIService24, are not available to these consumers.

<div class="p"><!----></div>
For analysis, the ping traces that are applied to the Poisson distributed service advertisements provide a unique multidimensional view for each consumer with respect to the underlying network behavior and therefore we should take the following two key issues into account when defining the metrics for such an experiment:

<div class="p"><!----></div>

<ul>
    <li>  <b>Optimal Performance:</b>  If the fragmentation perspective shown in Figure <a href="#indi:fig:poisson-10-adverts-frag">7</a> is applied algorithmically when analyzing the data, we can calibrate the results according to the optimal discovery performance a service discovery system "could" achieve for each service distribution. Therefore, a score of 100% should be achievable by a system that meets the design constraints of dynamics of the underlying network.
        <div class="p"><!----></div>
    </li>

    <li> <b>Accurate Service Detection:</b>   Since service distribution can be calibrated to the underlying network connectivity, we also have an accurate Consumer's view of the both the arrival and departure of services. Therefore, a success metric should take into account both the Service Discovery System's ability to detect the arrival of a service and the ability to detect when it is no longer available.
        <div class="p"><!----></div>
    </li>
</ul>

<div class="p"><!----></div>
As one can plainly see therefore, simple metrics therefore, such as "success rate" for discovery and the "latency" taken for the service discovery system to discover a service are insufficient for this experiment. In defining a rigorous scientific process for the evaluation of the results, it is important therefore to provide a model that calibrates the results with the above constraints to accurately get a picture of how optimal the system is.  For example, consider the following scenario: service A is advertised at second 2 of the emulation for 48 seconds.  Consumer1 discovers service A but then gets disconnected at second 4 of the emulation and returns in network view of service A at the 45 second on the emulation.  Clearly, here a service discovery system that states the service is available for the entire 46 seconds cannot be deemed successful because for 41 seconds, the service will be unavailable for use.

<div class="p"><!----></div>
A service discovery system therefore needs to track the services as they come in and out of range to give the consumer the highest accuracy possible to avoid service connection errors. In this paper, we use the notion of a "Quality of Service" (QoS)<a href="#tthFtNtABA" id="tthFrefABA"><sup>10</sup></a> to  define the success metric and then we record the latency of both the detection of the arrival and departure of a service.

<div class="p"><!----></div>
QoS is generally used in the context of networking and communication technologies and its goal is to (contractually) mitigate and eliminate unwanted impairments that impact the quality of voice, data and multimedia communications. Therefore, by applying a QoS metric to our service discovery systems, we are forcing a contractual commitment adhering to a certain level of service performance, robustness and reliability. This is in contrast to service discovery systems that happen to delivered on a best effort basis  i.e. without QoS guarantees. Therefore, the resulting QoS would naturally lead to a high quality of experience (QoE<a href="#tthFtNtABB" id="tthFrefABB"><sup>11</sup></a>) for a user that wishes to use a particular service. This approach leads to the use of the following two parameters that control the QoS:

<div class="p"><!----></div>

<dl>
    <dt><b>1. Service Discovery Detection for Service Arrival SDD<sub>a</sub>:</b></dt>
    <dd>   is a constant used to specify the maximum allowable number of seconds for the detection of the arrival of a service to the network.</dd>
    <dt><b>2. Service Discovery Detection for Service Departure SDD<sub>d</sub>:</b></dt>
    <dd>   is a constant  is used to specify the maximum allowable number of seconds for the detection of the departure of a service from the network.</dd>
</dl>

<div class="p"><!----></div>
and then the <b>Success Rate (SR)</b>  is a boolean (true or false) variable that is true if a service is discovered within the defined QoS,  specified below:

<div class="p"><!----></div>
<a id="qos">
</a>
<br clear="all" /><table border="0" width="100%"><tr><td>
    <table align="center" cellspacing="0"  cellpadding="2"><tr><td nowrap="nowrap" align="center">
        QoS  &#8801; (L<sub>a</sub>  &lt;  SDD<sub>a</sub>) &#8743;(L<sub>d</sub> &lt; SDD<sub>d</sub>) </td></tr></table>
</td><td width="1%">(1)</td></tr></table>



<div class="p"><!----></div>
where:

<div class="p"><!----></div>
<a id="discovery-latency">
</a>
<br clear="all" /><table border="0" width="100%"><tr><td>
    <table align="center" cellspacing="0"  cellpadding="2"><tr><td nowrap="nowrap" align="center">
        L<sub>a</sub> = &#124;(D<sub>a</sub> &#8722; A<sub>a</sub>)&#124; </td></tr></table>
</td><td width="1%">(2)</td></tr></table>



<div class="p"><!----></div>
<a id="leaving-latency">
</a>
<br clear="all" /><table border="0" width="100%"><tr><td>
    <table align="center" cellspacing="0"  cellpadding="2"><tr><td nowrap="nowrap" align="center">
        L<sub>d</sub> = &#124;(D<sub>d</sub> &#8722; A<sub>d</sub>)&#124; </td></tr></table>
</td><td width="1%">(3)</td></tr></table>



<div class="p"><!----></div>
and

<div class="p"><!----></div>

<ul>
    <li> <b>A<sub>a</sub></b> is the time the advert was advertised.
        <div class="p"><!----></div>
    </li>

    <li> <b>A<sub>d</sub></b> is the time of the departure of the advert.
        <div class="p"><!----></div>
    </li>

    <li> <b>D<sub>a</sub></b> is the time the discovery system discovered the advert.
        <div class="p"><!----></div>
    </li>

    <li> <b>D<sub>d</sub></b> is the time the discovery system discovered the departure of the advert.
        <div class="p"><!----></div>
    </li>
</ul>

<div class="p"><!----></div>
This QoS metric is applied to each of the 9 consumers after the connectivity matrix has been applied, in order to obtain an accurate percentage for the "optimal performance" a service discovery system should be capable of achieving for a particular set of services during the emulation. We believe this represents an accurate test for each system.

<div class="p"><!----></div>
<div class="normalsize"> <a id="tth_sEc7"></a><h2>
    7&nbsp;&nbsp;Experimental Results</h2>
<a id="sec:results">
</a>

For the INDI and JmDNS comparison, we performed the following emulations and post processing analysis scenarios according to different QoS requirements:

<div class="p"><!----></div>

<dl>
    <dt><b>Six Emulations:</b></dt>
    <dd> consisting of three different emulations for each discovery system. Each emulation uses a different mean Poisson interval of 10, 20 and 30 seconds for generating the  events, which results in different advertisement periodicities and advert density rates during the emulation, i.e. 27, 15 and 7 advertisements are generated, respectively. The different emulations types are labelled Poisson-10, Poisson-20 and Poisson-30 and specific runs are labelled INDI-10, INDI-20, INDI-30, JmDNS-10, JmDNS-20 and JmDNS-30 for convenience.</dd>
    <dt><b>Ninety Six Analysis Scenarios:</b></dt>
    <dd> which cover broad parametric range across the SDD<sub>a</sub> and SDD<sub>b</sub> parameters for specifying different QoS requirements. SDD<sub>a</sub> limits of 1, 2, 5 and 10 seconds and SDD<sub>b</sub> limits of 2, 5, 10 and 20 seconds were chosen (i.e. the total is 16 combinations for each of the 6 emulations = 96 cases).</dd>
</dl>

<div class="p"><!----></div>
<div class="footnotesize">
<div class="p"><!----></div>
<a id="tth_tAb2">
</a>
<div style="text-align:center">
    <table border="1">
        <tr><td align="center">SDS-Interval </td><td align="center">SDD<sub>a</sub> </td><td align="center">SDD<sub>d</sub>(2) </td><td align="center">SDD<sub>d</sub>(5) </td><td align="center">SDD<sub>d</sub>(10) </td><td align="center">SDD<sub>d</sub>(20)  </td></tr>
        <tr><td align="center">INDI-10 </td><td align="center">1 </td><td align="center">82.89 </td><td align="center">93.42  </td><td align="center">93.42 </td><td align="center">93.42 </td></tr>
        <tr><td align="center">INDI-10 </td><td align="center">2 </td><td align="center">87.28 </td><td align="center">100  </td><td align="center">100 </td><td align="center">100 </td></tr>
        <tr><td align="center">INDI-10 </td><td align="center">5 </td><td align="center">87.28 </td><td align="center">100  </td><td align="center">100 </td><td align="center">100 </td></tr>
        <tr><td align="center">INDI-10 </td><td align="center">10 </td><td align="center">87.28 </td><td align="center">100  </td><td align="center">100 </td><td align="center">100 </td></tr>
        <tr><td align="center">INDI-20 </td><td align="center">1 </td><td align="center">68.0 </td><td align="center">96.0  </td><td align="center">96.0 </td><td align="center">96.0 </td></tr>
        <tr><td align="center">INDI-20 </td><td align="center">2 </td><td align="center">72.0 </td><td align="center">100  </td><td align="center">100 </td><td align="center">100 </td></tr>
        <tr><td align="center">INDI-20 </td><td align="center">5 </td><td align="center">72.0 </td><td align="center">100  </td><td align="center">100 </td><td align="center">100 </td></tr>
        <tr><td align="center">INDI-20 </td><td align="center">10 </td><td align="center">72.0 </td><td align="center">100  </td><td align="center">100 </td><td align="center">100 </td></tr>
        <tr><td align="center">INDI-30 </td><td align="center">1 </td><td align="center">70.51 </td><td align="center">87.18  </td><td align="center">87.18 </td><td align="center">87.18 </td></tr>
        <tr><td align="center">INDI-30 </td><td align="center">2 </td><td align="center">83.33 </td><td align="center">100  </td><td align="center">100 </td><td align="center">100 </td></tr>
        <tr><td align="center">INDI-30 </td><td align="center">5 </td><td align="center">83.33 </td><td align="center">100  </td><td align="center">100 </td><td align="center">100 </td></tr>
        <tr><td align="center">INDI-30 </td><td align="center">10 </td><td align="center">83.33 </td><td align="center">100  </td><td align="center">100 </td><td align="center">100 </td></tr><tr><td></td></tr>
        <tr><td align="center">JmDNS-10 </td><td align="center">1 </td><td align="center">0.0 </td><td align="center">2.19 </td><td align="center">2.19 </td><td align="center">2.19 </td></tr>
        <tr><td align="center">JmDNS-10 </td><td align="center">2 </td><td align="center">3.95 </td><td align="center">38.6  </td><td align="center">69.74 </td><td align="center">75.44 </td></tr>
        <tr><td align="center">JmDNS-10 </td><td align="center">5 </td><td align="center">3.95 </td><td align="center">38.6  </td><td align="center">75.0 </td><td align="center">80.71 </td></tr>
        <tr><td align="center">JmDNS-10 </td><td align="center">10 </td><td align="center">3.95 </td><td align="center">39.91 </td><td align="center">78.95 </td><td align="center">84.65 </td></tr>
        <tr><td align="center">JmDNS-20 </td><td align="center">1 </td><td align="center">0 </td><td align="center">0 </td><td align="center">0 </td><td align="center">4.00 </td></tr>
        <tr><td align="center">JmDNS-20 </td><td align="center">2 </td><td align="center">3.2 </td><td align="center">26.4  </td><td align="center">43.2 </td><td align="center">57.6 </td></tr>
        <tr><td align="center">JmDNS-20 </td><td align="center">5 </td><td align="center">3.2 </td><td align="center">33.6  </td><td align="center">50.4 </td><td align="center">64.8 </td></tr>
        <tr><td align="center">JmDNS-20 </td><td align="center">10 </td><td align="center">3.2 </td><td align="center">33.6 </td><td align="center">57.6 </td><td align="center">72.0 </td></tr>
        <tr><td align="center">JmDNS-30 </td><td align="center">1 </td><td align="center">0 </td><td align="center">0 </td><td align="center">0 </td><td align="center">0 </td></tr>
        <tr><td align="center">JmDNS-30 </td><td align="center">2 </td><td align="center">5.13 </td><td align="center">19.23  </td><td align="center">38.46 </td><td align="center">55.13 </td></tr>
        <tr><td align="center">JmDNS-30 </td><td align="center">5 </td><td align="center">5.13 </td><td align="center">19.23  </td><td align="center">38.46 </td><td align="center">55.13 </td></tr>
        <tr><td align="center">JmDNS-30 </td><td align="center">10 </td><td align="center">5.13 </td><td align="center">19.23  </td><td align="center">38.46 </td><td align="center">55.13 </td></tr></table>

</div>
<a id="table:jmdns:comparison">
</a>

<div style="text-align:center">Table 2: JmDNS and INDI Overview of Results.</div>

<div class="p"><!----></div>
<div class="normalsize">
<div class="p"><!----></div>
<a id="tth_fIg8">
</a> <div style="text-align:center"><a href="indi10packet-distribution.png"><img src="indi10packet-distribution.png" alt=""></a>

    <div style="text-align:center">Figure 8: A histogram plotting the amount of network traffic INDI propagates onto the network per second for Poisson-10.</div>
    <a id="indi:fig:indi-10-traffic">
    </a>
</div>
<div class="p"><!----></div>
The "success rate" results for the various levels of SDD<sub>a</sub> and SDD<sub>d</sub> values for the complete set of experiments is provided in table <a href="#table:jmdns:comparison">2</a>.  It is clear that INDI out-performs JmDNS across the board, reaching 100% for SDD<sub>a</sub> values of 2 seconds and above and SDD<sub>d</sub> values of 5 seconds or above.   In fact, an SDD<sub>a</sub> value of 1.8 and  an SDD<sub>d</sub> value of 2.7 is enough to achieve 100% in all test cases for INDI covered in this study, the average being significantly less. This is discussed in depth in Section .

<div class="p"><!----></div>

<div class="p"><!----></div>
<a id="tth_fIg9">
</a> <div style="text-align:center"><a href="jmdns10packet-distribution.png"><img src="jmdns10packet-distribution.png" alt=""></a>

    <div style="text-align:center">Figure 9: A JmDNS traffic histogram showing the Poisson-10 case.   </div>
    <a id="indi:fig:jmdns-10-traffic">
    </a>
</div>
<div class="p"><!----></div>
JmDNS on the other hand due of its design cannot meet the requested QoS limits.  The dynamics of the network and services is far too extreme for the conservative mDNS timer settings, designed solely for use on a LAN. Also, the extra redundancy in the messaging involved in an mDNS handshake, increases the latency too much to meet the required QoS. This is discussed in more detail in the next section to cohabit with the mDNS handshaking discussion and bandwidth requirements.   The more general issues of responsiveness are discussed in Section .

<div class="p"><!----></div>
<a id="tth_sEc7.1"></a><h3>
    7.1&nbsp;&nbsp;Overhead Analysis</h3>
<a id="subsec:overhead">
</a>

<div class="p"><!----></div>

<div class="p"><!----></div>
<a id="tth_fIg10">
</a> <div style="text-align:center"><a href="indi20packet-distribution.png"><img src="indi20packet-distribution.png" alt=""></a>

    <div style="text-align:center">Figure 10: An INDI traffic histogram showing the Poisson-20 case.</div>
    <a id="indi:fig:indi-20-traffic">
    </a>
</div>
<div class="p"><!----></div>
At a high level, INDI and JmDNS operate in different modes.  INDI employs more of a proactive approach when addressing mobility whereas JmDNS has a defined sequence of message handshakes between JmDNS responders, which follow a combination of proactive and reactive solicitation.  However, in the JmDNS case, this interaction has a high short-term burst rate of several seconds and then a period of inactivity in transmitting messages across the network.  For INDI however, it proactively announces at a specific interval (1 second in these emulations) through the entire emulation. Therefore, although there are some minor peaks during service advertisement switch over in the INDI overhead histogram, this explains why is it is far more smooth overall.   Figures <a href="#indi:fig:indi-10-traffic">8</a>, <a href="#indi:fig:jmdns-10-traffic">9</a>, <a href="#indi:fig:indi-20-traffic">10</a>, ,  and  show the traffic overhead caused by INDI and JmDNS for the three test cases covering Poisson mean intervals of 10, 20 and 30 seconds, respectively.

<div class="p"><!----></div>

<div class="p"><!----></div>
<a id="tth_fIg11">
</a> <div style="text-align:center"><a href="jmdns20packet-distribution.png"><img src="jmdns20packet-distribution.png" alt=""></a>

    <div style="text-align:center">Figure 11: A JmDNS traffic histogram showing the Poisson-20 case.   </div>
    <a id="indi:fig:jmdns-20-traffic">
    </a>
</div>
<div class="p"><!----></div>
Figures <a href="#indi:fig:indi-10-traffic">8</a> and <a href="#indi:fig:jmdns-10-traffic">9</a> show the traffic for the 10  second Poisson interval case.   It might seem clear from the proactive scheme that INDI sends out far more service advertisement requests with a shorter interval, creating consistent periodic traffic throughout the duration of the emulation. However, INDI messages are sent once and are not subjected to a number of handshakes with the client. In these experiments therefore, we can see that there are a lot less INDI messages and far less bandwidth consumed overall.  For each service advertisement request, JmDNS exchanges tens of message every time a service arrives onto the network and then remains quiet until the next advert comes onto the network.  This results in a far higher traffic burst rate and an accumulation of messages. Looking more closely at the scales in Figures <a href="#indi:fig:indi-10-traffic">8</a> and <a href="#indi:fig:jmdns-10-traffic">9</a>, we can in fact see that the JmDNS scale is one order of magnitude higher than that of INDI and hence, the total traffic consumed for INDI is 2.13 MB for the duration of the experiment, compared to 10.68MB for JmDNS.

<div class="p"><!----></div>

<div class="p"><!----></div>
<a id="tth_fIg12">
</a> <div style="text-align:center"><a href="indi30packet-distribution.png"><img src="indi30packet-distribution.png" alt=""></a>

    <div style="text-align:center">Figure 12: An INDI traffic histogram showing the Poisson-30 case.   </div>
    <a id="indi:fig:indi-30-traffic">
    </a>
</div>
<div class="p"><!----></div>

<div class="p"><!----></div>
Considering the rather significant gains in success rates for INDI compared to JmDNS, it is somewhat surprising at first glance that JmDNS generates more traffic.  However, let's consider further evidence from our previous experiments [].  In this experiment, we used Wireshark<a href="#tthFtNtABC" id="tthFrefABC"><sup>12</sup></a>, a sophisticated tool for capturing and parsing packets on the network, to observe the messages exchanged for a single service advertisement from INDI in Proactive mode and JmDNS, using a simple loopback network connector.  It was found that upon bootstrapping and discovering the first service on the network, a JmDNS node traverses through various stages e.g. server probing (three times), announcing (three two times) for resolving addresses and thereafter a further sequence for resolving services e.g. probers, announcers, and then type, service and service info resolvers.   This verbose activity results in 25 messages being exchanged between two JmDNS services to make the first discovery.  Thereafter, only the service sequence is followed but again this is several exchanges per service advertisement and thus causes large peaks at service interval times.

<div class="p"><!----></div>
The explanation for this extra bandwidth has already been discussed in Section <a href="#sec:background">2</a>.  Since mDNS was designed to cover all LAN use cases, this is bound to have a knock on effect in terms of redundancy. Although a factor of 5 might at first glance seem high, mDNS attempts to deal with all combinations of clients and servers arriving at different times and is designed for an environment where services do not come onto the network very frequently.  Therefore, for example, over the course of several hours with one service arriving per hour (which is more in tune with the design requirements of mDNS), mDNS would indeed perform more efficiently than INDI set in proactive mode.  And although INDI could in theory be tuned to exhibit a similar behavior to mDNS by using a combination of proactive and reactive modes, it would unlikely to provide any benefit at all for use within a LAN.    So, the choice between the two for bandwidth efficiency depends completely on the dynamic nature of the services and the environment they are run in. Within a MANET however, the gains are clearly in the favor of INDI.

<div class="p"><!----></div>

<div class="p"><!----></div>
<a id="tth_fIg13">
</a> <div style="text-align:center"><a href="jmdns30packet-distribution.png"><img src="jmdns30packet-distribution.png" alt=""></a>

    <div style="text-align:center">Figure 13: A JmDNS traffic histogram showing the Poisson-30 case.   </div>
    <a id="indi:fig:jmdns-30-traffic">
    </a>
</div>
<div class="p"><!----></div>
Figures <a href="#indi:fig:indi-20-traffic">10</a>, <a href="#indi:fig:jmdns-20-traffic">11</a>, <a href="#indi:fig:indi-30-traffic">12</a> and <a href="#indi:fig:jmdns-30-traffic">13</a> for Poisson-20 and Poisson-30 cases tell a similar story.  However, the results are not so extreme because there are less adverts being advertised during the course of the emulation.  For the 20 second interval, there are 15 service advertisements and for the 30 second interval, there are only 7. Therefore, the amount of traffic consumed is less for all cases.  The reductions in traffic for JmDNS are significant and depend directly on the number of advertisements. For example, whereas the JmDNS traffic for Poisson-10 was  10.68MB, Poisson-20 was 6.13 and Poisson-30 was 3.96, for INDI the traffic rates were 2.13, 1.98 and 1.88 MBs, respectively.  Even with 7 advertisements across the 250 second duration (less than two per minute), INDI still consumed less than half the traffic of JmDNS.  Further, as the result in table <a href="#table:jmdns:comparison">2</a> shows, the success rates for INDI are more than twice that of JmDNS in these cases. For traffic therefore, there is little evidence from this study that the extra bandwidth consumed by JmDNS is having any effect of service discovery in this environment.  In the next section, we look at the the Poisson-10  and study the advert distribution and the reasons for the success differences between INDI and JmDNS more closely.

<div class="p"><!----></div>
<a id="tth_sEc7.2"></a><h3>
    7.2&nbsp;&nbsp;A Closer Look at 10 Second Interval Case</h3>
<a id="indi:sec:indepth">
</a>

<div class="p"><!----></div>

<div class="p"><!----></div>
<a id="tth_fIg14">
</a> <div style="text-align:center"><a href="indi10-1-2-results-distribution.png"><img src="indi10-1-2-results-distribution.png" alt=""></a>

    <div style="text-align:center">Figure 14: INDI: Shows the fragmentation pattern that affects the services' availability, the arrival and departure of each advert and the corresponding indication of successful detection of that advert (Y = success, N = failure).</div>
    <a id="indi:fig:poisson-10-1-2">
    </a>
</div>
<div class="p"><!----></div>
By observing the location and duration of the adverts during the course of the emulation for the Poisson-10 case, we discuss in this Section why certain adverts succeeded to be detected by a discovery systems and why others failed. Although we have 32 different cases in this category, we consider the two extreme cases here for illustration:

<div class="p"><!----></div>

<ol type="1">
    <li> An  SDD<sub>a</sub> of 1 second and an SDD<sub>d</sub> 2 seconds.
        <div class="p"><!----></div>
    </li>

    <li> An SDD<sub>a</sub> of 10 seconds and an SDD<sub>d</sub> of 20  seconds.
        <div class="p"><!----></div>
    </li>
</ol>

<div class="p"><!----></div>
In Figure <a href="#indi:fig:poisson-10-1-2">14</a>, we show the performance of INDI when it has been requested to meet an SDD<sub>a</sub> of 1 second and an SDD<sub>d</sub> of 2 seconds. This plot shows a number of different things.   First, it overlays the connectivity diagram that representations the fragmentation in the network shown  in Figure <a href="#indi:fig:emulationconnectivity">5</a>.  It then shows each service advertised during the course of the emulation (as per Figure <a href="#indi:fig:poisson-10-adverts">6</a>) labelled by name on the y axis and annotated by a Y (success) or N (failure) if the service discovery system was able to detect that advert or not.   The services are also calibrated to show their visibility for consumers 5-9 after the fragmentation has been applied (as per Figure <a href="#indi:fig:poisson-10-adverts-frag">7</a>). Finally, the statistics are provided about this run as a label at the top part of the graph, in the form:

<div class="p"><!----></div>

<pre>
INDI&nbsp;(QoSa&nbsp;1.0&nbsp;QoSd&nbsp;2.0)&nbsp;SR&nbsp;82.89&nbsp;SDDa&nbsp;0.12&nbsp;SDDd&nbsp;1.31

</pre>

<div class="p"><!----></div>
which describe the parameters defined in Section <a href="#sec:methodology">6</a>. This example shows that the INDI discovery system when applied to QoS parameters of SDD<sub>a</sub> of 1 second and SDD<sub>d</sub> of 2 seconds achieve as success rate (SR) of 82.89%, an average service detection delay for arrival of 0.12 seconds and an average service detection delay for departure of 1.31 seconds.

<div class="p"><!----></div>

<div class="p"><!----></div>
<a id="tth_fIg15">
</a> <div style="text-align:center"><a href="jmdns10-1-2-results-distribution.png"><img src="jmdns10-1-2-results-distribution.png" alt=""></a>

    <div style="text-align:center">Figure 15: JmDNS: Successful service detection (Y = success, N = failure).</div>
    <a id="jmdns:fig:poisson-10-1-2">
    </a>
</div>
<div class="p"><!----></div>
Although INDI succeeds in detecting all of the services in the emulation, it cannot meet this QoS rate to the full. Looking in more detail at Figure <a href="#indi:fig:poisson-10-1-2">14</a>, we can see that services around the fragmentations cause the most issues and since a success rate is applied to all consumers for each service, then the fragmented consumers are having a larger impact here.   The explanation for this affect is to do with the quantization of the proactive readvertisement interval and its alignment to services appearing and disappearing from the network.  Since INDI employed a proactive service announcement scheme (of rate 1 per second and a TTL of 2 seconds) for this experiment, these results are somewhat expected.   And upon further finer-grained analysis of the data, it was found in fact that an SDD<sub>a</sub> value of 1.8 and  an SDD<sub>d</sub> value of 2.7 is enough to achieve 100% in all test cases for INDI covered in this study.

<div class="p"><!----></div>
The SDD<sub>d</sub> rate can be explained because when a service is deleted there is a slightly delay (100-200 ms) on the server whilst it starts the <em>RecordReaper</em>  to detect the advert is expired.  During this time, it is possible in some case for the producer to proactively readvertise the service for a further TTL of 2 seconds.  And then on the service side,  since it takes 300-400 milliseconds to register a service in some cases, the range of 2.7 seconds can be expected in extreme circumstances.

<div class="p"><!----></div>
To combat these affects, INDI allows the tuning of both the proactive service announcement interval and the TTL for a service advertisement. Decreasing these values can improve responsiveness of the system, with the overhead of increased network bandwidth.  The decision for setting these values is application and network dependent.

<div class="p"><!----></div>

<div class="p"><!----></div>
<a id="tth_fIg16">
</a> <div style="text-align:center"><a href="indi10-10-20-results-distribution.png"><img src="indi10-10-20-results-distribution.png" alt=""></a>

    <div style="text-align:center">Figure 16: INDI: Successful service detection (Y = success, N = failure).</div>
    <a id="indi:fig:poisson-10-10-20">
    </a>
</div>
<div class="p"><!----></div>
In Figure <a href="#jmdns:fig:poisson-10-1-2">15</a>, the story is quite different.  JmDNS was unable to discover any services using these values for the QoS metric. Not only does JmDNS suffer from a finite advertisement sequence (several seconds normally) and therefore misses a number of adverts that go out of range because of this, it also does not provide sufficient timely notification internally when success has been reached. Therefore, JmDNS needs far more time to respond successfully to service advertisements and therefore, it cannot meet the dynamics exhibited here and the level of QoS defined.

<div class="p"><!----></div>
This is explained again by the significantly different design priorities for mDNS when discovering services.  Rather than dealing with responsiveness, it performs multiple queries in order to ensure the discovery of the new longer lived services but also, it attempts to deal with maintaining the state of node IP addresses in case of conflicts.  This extra level of state maintenance creates an extra overhead on the network that introduces more traffic and a longer delay in the initial discovery. This is therefore not a failing of JmDNS but rather a mismatch of its intended purpose. However, it does stress the importance on the level of configurability for offering flexible modes and timers that INDI strives to achieve.

<div class="p"><!----></div>

<div class="p"><!----></div>
<a id="tth_fIg17">
</a> <div style="text-align:center"><a href="jmdns10-10-20-results-distribution.png">Figure</a>

    <div style="text-align:center">Figure 17: JmDNS: Successful service detection (Y = success, N = failure).</div>
    <a id="jmdns:fig:poisson-10-10-20">
    </a>
</div>
<div class="p"><!----></div>
The extended time period for SDD<sub>a</sub> of 10 seconds and SDD<sub>d</sub> of 20 seconds in Figure <a href="#indi:fig:poisson-10-10-20">16</a> provides plenty of headroom for INDI to meet the expectations stated in the QoS. INDI achieves 100% success with a delay of 0.21 seconds for the discovery of a service and an average of 1.63 seconds for the detection of a service when it departs from the network.

<div class="p"><!----></div>
In Figure <a href="#jmdns:fig:poisson-10-10-20">17</a> however, with a SDD<sub>a</sub> of 10 second and SDD<sub>d</sub> of 20 seconds, JmDNS  cannot achieve 100%.  Its success rate is 84.65% and it has a delay of 1.69 seconds for the discovery of a service (1.48 more than INDI) and an average of 4.7 seconds for the detection of a service (3.07 seconds more than INDI) when it departs from the network.

<div class="p"><!----></div>
It is clear here, even with generous QoS constraints, that JmDNS suffers from the fragmentation of Consumers 5 to 9 when discovering services. It failed on <em>MDNSService</em> services numbered 5, 10, 13, 16, 21 and 24.  All of these services either joined or left the network during the advertisement.  This can be explained by the follow reasons:

<div class="p"><!----></div>

<ul>
    <li> <b>Services disappearing through fragmentation:</b> When a service is fragmented, mDNS has no mechanism for detecting this event. The TTL for an mDNS advert is 2 hours by default and since the producer does not know that consumers have gone out of range, it cannot notify them, and even if it did, there would be no connection.   Therefore, mDNS will always fail in this respect.  For INDI, it implements an adjustable TTL, which determines the rate at which adverts need to be refreshed and therefore it can detect absences.
        <div class="p"><!----></div>
    </li>

    <li> <b>Services reappearing after fragmentation:</b> When a service reappears after a fragmentation, then mDNS can only discover it if it appears within its finite sequence of handshakes when a new service is advertised.  Therefore, MDNSService 17 was discovered by mDNS because it was advertised only a second or so before it came back into range and therefore within the normal mDNS handshaking sequence range.  Other advertisements could not be discovered because the interval was beyond its probing and announcement phases.
        <div class="p"><!----></div>
    </li>
</ul>

<div class="p"><!----></div>
<a id="tth_sEc8"></a><h2>
    8&nbsp;&nbsp;Conclusions</h2>
<a id="sec:conclusions">
</a>

<div class="p"><!----></div>
In this paper, we have described the motivation, architecture, design, implementation and comparative analysis of INDI compared to an existing solutions for standardized service discovery on a local area network.   We have explained how  INDI achieves full interoperability with mDNS and that it offers attractive flexible service discovery profiles for optimization  in mobile networks.

<div class="p"><!----></div>
We have shown that INDI outperforms mDNS for a simple wireless networking mobile MANET scenario.  For bandwidth consumption, INDI achieved up to a six fold reduction in messages.  For success rates, even according to a modest quality of service metric for latencies of discovery and departure of services, INDI achieved at least a 17% superior difference in results. It proved to be far more responsive and adaptable to network change.

<div class="p"><!----></div>
Since the operating nature of INDI is peer-to-peer and therefore service providers advertise their own services, such gains make a significant difference. If INDI can provide more up-to-date service advertisements for exposing application endpoints, it follows therefore the connection to its endpoint to use the application is also likely to be more successful too.   This results in a far higher quality of experience for using services in a MANET environment in general.

<div class="p"><!----></div>
Regarding future work we feel that INDI work could contribute in helping specify an open standard multi-hop multicast capable extension to mDNS and potentially other link local service discovery systems. Site-scoped multicast forwarding in mobile ad hoc networks is an example of where this could be applied in the short term.  Appropriate domains and rules need to be developed to make this both consistent and interoperable with mDNS and the DNS architecture.  Presently INDI provides a working prototype demonstrating that this type of design adaptation is achievable and beneficial.


<div class="p"><!----></div>

<h2>Acknowledgments</h2>

<div class="p"><!----></div>
INDI work has been funded in part by the Office of Naval Research (ONR) Service Oriented Networks Operating in MANET (SONOMA) project.  Work in developing  mDNS interpoperability has been supported in part by the Groupwise Tactical Edge networking (GTEN) effort under Networks Programs within the Office of the Assistant Secretary of Defense (OASD), Research and Engineering. The authors wish like to thank Brian Adamson for his advice and SMF implementation used as an experimentation tool. We would also like to thank Andrew Harrison and Justin Dean for their work on the initial INDI implementation and experimentation efforts.  Finally, we would  like to thank the JmDNS team, and in particular, Pierre Frisch, who provided insight, guidance and exposed the timing interfaces for JmDNS tasks that made this work possible.


<div class="p"><!----></div>
</div></div></div></div></span><hr /><h3>Footnotes:</h3>

<div class="p"><!----></div>
<a id="tthFtNtAAB"></a><a href="#tthFrefAAB"><sup>1</sup></a>http://www.apple.com/support/bonjour/
<div class="p"><!----></div>
<a id="tthFtNtAAC"></a><a href="#tthFrefAAC"><sup>2</sup></a>http://avahi.org/
<div class="p"><!----></div>
<a id="tthFtNtAAD"></a><a href="#tthFrefAAD"><sup>3</sup></a>Restless was developed by Andrew Harrison, now working for  the Carefx Corporation but not yet released publicly
<div class="p"><!----></div>
<a id="tthFtNtAAE"></a><a href="#tthFrefAAE"><sup>4</sup></a>http://jquery.com/
<div class="p"><!----></div>
<a id="tthFtNtAAF"></a><a href="#tthFrefAAF"><sup>5</sup></a>http://en.wikipedia.org/wiki/Comet_(programming)
<div class="p"><!----></div>
<a id="tthFtNtAAG"></a><a href="#tthFrefAAG"><sup>6</sup></a>http://www.jstree.com/
<div class="p"><!----></div>
<a id="tthFtNtAAH"></a><a href="#tthFrefAAH"><sup>7</sup></a>http://www.videolan.org/vlc/
<div class="p"><!----></div>
<a id="tthFtNtAAI"></a><a href="#tthFrefAAI"><sup>8</sup></a>http://www.igniterealtime.org/projects/openfire/
<div class="p"><!----></div>
<a id="tthFtNtAAJ"></a><a href="#tthFrefAAJ"><sup>9</sup></a>The term connected here simply means that a consumer node should be able to receive multicast packets from the producer - it does not imply any protocol-specific usages of this term e.g. TCP.
<div class="p"><!----></div>
<a id="tthFtNtABA"></a><a href="#tthFrefABA"><sup>10</sup></a>http://en.wikipedia.org/wiki/Quality_of_service
<div class="p"><!----></div>
<a id="tthFtNtABB"></a><a href="#tthFrefABB"><sup>11</sup></a>http://en.wikipedia.org/wiki/Quality_of_experience
<div class="p"><!----></div>
<a id="tthFtNtABC"></a><a href="#tthFrefABC"><sup>12</sup></a>http://www.wireshark.org/
<br /><br /><hr /><small>File translated from
    T<sub><span class="small">E</span></sub>X
    by <a href="http://hutchinson.belmont.ma.us/tth/">
        T<sub><span class="small">T</span></sub>H</a>,
    version 4.03.<br />On 14 May 2012, 21:16.</small>
</div>
</div>
</body>
</html>
